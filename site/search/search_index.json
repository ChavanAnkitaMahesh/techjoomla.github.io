{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"hierarchy-management/hierarchy-manager-overview/","text":"Hierarchy Management is an horizontal (Infrastructure) extension by Techjoomla that allows setting up general or context specific hierarchical relations between users. This can be used by other extensions to allow special access control, generate reports and so on.","title":"Overview"},{"location":"joomla-rest-api/com-api-impersonation/","text":"Overview \u00b6 Using the impersonation feature it is possible for a Super Admin user to impersonate another user. To use this feature, the token being used for an API call should be belonging to a Super Admin user (specifically, any user having the core.admin permission). To impersonate another user, pass the header X-Impersonate . The value of the header is the user id of the user to impersonate eg: X-Impersonate : 42 . It is also possible to use the username or email of the user eg: X-Impersonate : email:user@email.com or X-Impersonate : username:ashwin . Security Note When using this feature, we recommend the below steps to improve the security of your setup Create a new token to be used only for impersonation instead of using an existing token. Absolutely avoid using this token for client side requests. Use it only in server side communication. More details of how this works \u00b6 Normally, the com_api framework sets the JUser object for any API call based on the token passed in the Authorization header. Plugins can then access the user object making the API call via $this->plugin->get('user') . This feature adds support for a new X-Impersonate header which allows the API caller to set a different user than the one making the API call. The Impersonate header can accept either the id, username or email of the user to impersonate. The Impersonate header cannot be used by all users, only by Super Users. Example \u00b6 Consider the example below ID Name Email API Token Level 20 Rahul rahul@mail.com rrrrrr Super User 21 Jaya jaya@mail.com jjjjjj Registered 22 Kevin kevin@mail.com kkkkkkk Registered Case 1 GET /jgive/campaign \"Authorization\": \"Bearer rrrrrr\" \"X-Impersonate\": \"21\" In this case the user object available to the campaign resource will be that of userid 21. Case 2 GET /jgive/campaign \"Authorization\": \"Bearer jjjjjj\" \"X-Impersonate\": \"22\" This API call will return a 403 error since the user with token jjjjjj is not allowed to use impersonation. Case 3 GET /jgive/campaign \"Authorization\": \"Bearer rrrrrr\" \"X-Impersonate\": \"email:kevin@mail.com\" In this case the user object available to the campaign resource will be that of userid 22 i.e. the user with the email kevin@mail.com Case 4 GET /jgive/campaign \"Authorization\": \"Bearer jjjjjj\" This is how com_api works as of today, the campaign resource will receive the user object for userid 21 Info Feature available since v2.4.0","title":"Impersonating another user"},{"location":"joomla-rest-api/com-api-impersonation/#overview","text":"Using the impersonation feature it is possible for a Super Admin user to impersonate another user. To use this feature, the token being used for an API call should be belonging to a Super Admin user (specifically, any user having the core.admin permission). To impersonate another user, pass the header X-Impersonate . The value of the header is the user id of the user to impersonate eg: X-Impersonate : 42 . It is also possible to use the username or email of the user eg: X-Impersonate : email:user@email.com or X-Impersonate : username:ashwin . Security Note When using this feature, we recommend the below steps to improve the security of your setup Create a new token to be used only for impersonation instead of using an existing token. Absolutely avoid using this token for client side requests. Use it only in server side communication.","title":"Overview"},{"location":"joomla-rest-api/com-api-impersonation/#more-details-of-how-this-works","text":"Normally, the com_api framework sets the JUser object for any API call based on the token passed in the Authorization header. Plugins can then access the user object making the API call via $this->plugin->get('user') . This feature adds support for a new X-Impersonate header which allows the API caller to set a different user than the one making the API call. The Impersonate header can accept either the id, username or email of the user to impersonate. The Impersonate header cannot be used by all users, only by Super Users.","title":"More details of how this works"},{"location":"joomla-rest-api/com-api-impersonation/#example","text":"Consider the example below ID Name Email API Token Level 20 Rahul rahul@mail.com rrrrrr Super User 21 Jaya jaya@mail.com jjjjjj Registered 22 Kevin kevin@mail.com kkkkkkk Registered Case 1 GET /jgive/campaign \"Authorization\": \"Bearer rrrrrr\" \"X-Impersonate\": \"21\" In this case the user object available to the campaign resource will be that of userid 21. Case 2 GET /jgive/campaign \"Authorization\": \"Bearer jjjjjj\" \"X-Impersonate\": \"22\" This API call will return a 403 error since the user with token jjjjjj is not allowed to use impersonation. Case 3 GET /jgive/campaign \"Authorization\": \"Bearer rrrrrr\" \"X-Impersonate\": \"email:kevin@mail.com\" In this case the user object available to the campaign resource will be that of userid 22 i.e. the user with the email kevin@mail.com Case 4 GET /jgive/campaign \"Authorization\": \"Bearer jjjjjj\" This is how com_api works as of today, the campaign resource will receive the user object for userid 21 Info Feature available since v2.4.0","title":"Example"},{"location":"joomla-rest-api/com-api-introduction/","text":"Intro - what is com_api ? \u00b6 com_api is a quick and easy way to add REST APIs to Joomla. Extendible via plugins, you can easily add support for more Joomla extensions. To get started, download the component and install the API plugins you need. Enable the plugins and you are ready to fetch your content via APIs. To add additional resources to the API, plugins need to be created. Each plugin can provide multiple API resources. Plugins are a convenient way to group several resources. Eg: A single plugin could be created for an 'e-commerce' component with separate resources for products, cart, checkout, orders etc. com_api terminology (plugin terms) \u00b6 app \u00b6 An app is essentially a Joomla plugin. However, the plugin itself does nothing more than load the resources it contains. So the app is mainly used to package the API plugin and to enable adding any API specific parameters. Each app will have one or more resources. resource \u00b6 Resources are files that have code to accept input and set the API output. You will usually have multiple resources in an app. A common use case is for an extension like Easysocial or Jomsocial to have a single app. The app contains resources for various objects like groups, events, photos, newsfeed etc. The resource will contain the methods get() post() delete() to perform CRUD operations on that type of object. key / token \u00b6 The key is used to access authenticated resources. The admin section allows you to create keys. It's also possible to use the /api/user/login API to login using username and password and get a token in response.","title":"Introduction"},{"location":"joomla-rest-api/com-api-introduction/#intro-what-is-com_api","text":"com_api is a quick and easy way to add REST APIs to Joomla. Extendible via plugins, you can easily add support for more Joomla extensions. To get started, download the component and install the API plugins you need. Enable the plugins and you are ready to fetch your content via APIs. To add additional resources to the API, plugins need to be created. Each plugin can provide multiple API resources. Plugins are a convenient way to group several resources. Eg: A single plugin could be created for an 'e-commerce' component with separate resources for products, cart, checkout, orders etc.","title":"Intro - what is com_api?"},{"location":"joomla-rest-api/com-api-introduction/#com_api-terminology-plugin-terms","text":"","title":"com_api terminology (plugin terms)"},{"location":"joomla-rest-api/com-api-introduction/#app","text":"An app is essentially a Joomla plugin. However, the plugin itself does nothing more than load the resources it contains. So the app is mainly used to package the API plugin and to enable adding any API specific parameters. Each app will have one or more resources.","title":"app"},{"location":"joomla-rest-api/com-api-introduction/#resource","text":"Resources are files that have code to accept input and set the API output. You will usually have multiple resources in an app. A common use case is for an extension like Easysocial or Jomsocial to have a single app. The app contains resources for various objects like groups, events, photos, newsfeed etc. The resource will contain the methods get() post() delete() to perform CRUD operations on that type of object.","title":"resource"},{"location":"joomla-rest-api/com-api-introduction/#key-token","text":"The key is used to access authenticated resources. The admin section allows you to create keys. It's also possible to use the /api/user/login API to login using username and password and get a token in response.","title":"key / token"},{"location":"joomla-rest-api/com-api-making-api-calls/","text":"How to call API resources? \u00b6 To make an API call, We need to set: API URL, authentication headers, output format 1. Set API URLs \u00b6 Non-SEF URLs \u00b6 If you do not have SEF URLs enabled, use the endpoint URL as index.php?option=com_api&app={app}&resource={resource}&format=raw Example for users plugin could be: index.php?option=com_api&app=users&resource=user&id=619&format=raw SEF URLs \u00b6 SEF URL to access any route is of the format /api/{plugin}/{resource} Example for users plugin could be: /api/users/user/619 Info To enable SEF URLs for endpoints, make sure you have created a Joomla menu of the type API > API Endpoint. If you create the menu using any other alias than api make sure you use the apppropriate slug in the endpoint. Tip If your resource expects an id parameter in the URL, you can use /api/{plugin}/{resource}/{id} as the API url. Other querystring need to be sent as is. 2. Set Authentication header \u00b6 While it is possible for an app to make an entire resource or a specific HTTP method in a resource public, other non-public resources will need API token for authentication. The token needs to be passed via the Authorization header using the Bearer scheme eg: Authorization: Bearer <token> . Info Previous versions also allowed passing the token as a querystring variable with the name key . The querystring approach will be deprecated in the future version. Note Sometimes Apache does not pass on the Authorization header, in such cases send then token using the X-Authorization header i.e. X-Authorization: Bearer {token} 3. Set Output Format \u00b6 The default output format is JSON. However it's also possible to get XML output by setting the Accept: application/xml header. Example url call \u00b6 An example curl call may look like this: curl --location --request GET 'http://{{host}}/index.php?option=com_api&app=users&resource=user&id=619&format=raw' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'Authorization: Bearer c8b16517a0a21c446f1ee9980944cd7e' Overriding Output \u00b6 If you wish to modify the 'envelope' of the response: you can copy the file components/com_api/libraries/response/jsonresponse.php paste into templates/{your template}/json/api.php and modify the structure of the output. Info A similar override is possible by creating a xml.php as well.","title":"Making calls to API resources"},{"location":"joomla-rest-api/com-api-making-api-calls/#how-to-call-api-resources","text":"To make an API call, We need to set: API URL, authentication headers, output format","title":"How to call API resources?"},{"location":"joomla-rest-api/com-api-making-api-calls/#1-set-api-urls","text":"","title":"1. Set API URLs"},{"location":"joomla-rest-api/com-api-making-api-calls/#non-sef-urls","text":"If you do not have SEF URLs enabled, use the endpoint URL as index.php?option=com_api&app={app}&resource={resource}&format=raw Example for users plugin could be: index.php?option=com_api&app=users&resource=user&id=619&format=raw","title":"Non-SEF URLs"},{"location":"joomla-rest-api/com-api-making-api-calls/#sef-urls","text":"SEF URL to access any route is of the format /api/{plugin}/{resource} Example for users plugin could be: /api/users/user/619 Info To enable SEF URLs for endpoints, make sure you have created a Joomla menu of the type API > API Endpoint. If you create the menu using any other alias than api make sure you use the apppropriate slug in the endpoint. Tip If your resource expects an id parameter in the URL, you can use /api/{plugin}/{resource}/{id} as the API url. Other querystring need to be sent as is.","title":"SEF URLs"},{"location":"joomla-rest-api/com-api-making-api-calls/#2-set-authentication-header","text":"While it is possible for an app to make an entire resource or a specific HTTP method in a resource public, other non-public resources will need API token for authentication. The token needs to be passed via the Authorization header using the Bearer scheme eg: Authorization: Bearer <token> . Info Previous versions also allowed passing the token as a querystring variable with the name key . The querystring approach will be deprecated in the future version. Note Sometimes Apache does not pass on the Authorization header, in such cases send then token using the X-Authorization header i.e. X-Authorization: Bearer {token}","title":"2. Set Authentication header"},{"location":"joomla-rest-api/com-api-making-api-calls/#3-set-output-format","text":"The default output format is JSON. However it's also possible to get XML output by setting the Accept: application/xml header.","title":"3. Set Output Format"},{"location":"joomla-rest-api/com-api-making-api-calls/#example-url-call","text":"An example curl call may look like this: curl --location --request GET 'http://{{host}}/index.php?option=com_api&app=users&resource=user&id=619&format=raw' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'Authorization: Bearer c8b16517a0a21c446f1ee9980944cd7e'","title":"Example url call"},{"location":"joomla-rest-api/com-api-making-api-calls/#overriding-output","text":"If you wish to modify the 'envelope' of the response: you can copy the file components/com_api/libraries/response/jsonresponse.php paste into templates/{your template}/json/api.php and modify the structure of the output. Info A similar override is possible by creating a xml.php as well.","title":"Overriding Output"},{"location":"joomla-rest-api/com-api-mobile-app-use-case/","text":"Let's consider you are building a mobile app with Joomla as backend for APIs. You can use com_api, plg_api_users, and create your own API plugins as needed. Pre-requisites You have installed latest com_api and its latest user plugin And, you have built a mobile application which interacts with your website Steps for com_api as Rest API provider \u00b6 Steps to get auth token \u00b6 1.1 From the mobile app, when user wants to login for very first time - user will enter username and password in the mobile application login form. 1.2 Your mobile app will catch those credentials, 1.3 and make an API call as below Example: Method POST URL { {host } }/index.php?option=com_api&app=users&resource=login&format=raw Headers Content-Type: application/x-www-form-urlencoded Post Data username: user entered value password: user entered value CURL example curl --location --request POST 'http://{{host}}/index.php?app=users&resource=login&option=com_api&format=raw' \\ --form 'username=example@gmail.com' \\ --form 'password=passwordGoesHere' Response If credentials are correct, you will get a response, which looks like { \"err_msg\" : \"\" , \"err_code\" : \"\" , \"response_id\" : 214 , \"api\" : \"users.login\" , \"version\" : \"\" , \"data\" : { \"auth\" : \"c8b16517a0a21c446f1ee9980944cd7e\" , \"code\" : \"200\" , \"id\" : \"653\" , \"jwt\" : \"eyJ0eXAiOiJKV1QiLCJhreebGciOiJIUzI1NiJ9.eyJpZCI6IjY1MyJ9.rere-ZAhpXYXvCHuZbqqTmtwjUvlv8ZnA2t-PxzI\" } } Steps to use auth token for subsequent API calls \u00b6 2.1 Once you get the response to above, you get an auth key, which you can use for next API calls 2.2 Your mobile app should store the auth key lets say local storage or whatever way you prefer \"auth\": \"c8b16517a0a21c446f1ee9980944cd7e\" 3.0 Now, for subsequent API calls you can pass this auth key in the header and still access APIs without passing username and password. Example: Method GET URL { {host } }/index.php?option=com_api&app=users&resource=user&format=raw&id= 619 Headers Content-Type: application/x-www-form-urlencoded Authorization: Bearer c 8 b 16517 a 0 a 21 c 446 f 1 ee 9980944 cd 7 e CURL example curl --location --request GET 'http://{{host}}/index.php?app=users&resource=login&option=com_api&format=raw' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'Authorization: Bearer c8b16517a0a21c446f1ee9980944cd7e' Response You will get a response, which looks like { \"err_msg\" : \"\" , \"err_code\" : \"\" , \"response_id\" : 218 , \"api\" : \"users.user\" , \"version\" : \"\" , \"data\" : { \"id\" : \"619\" , \"name\" : \"asdasd adasda\" , \"username\" : \"asdadad\" , \"email\" : \"asdsd@asdasd.com\" , \"block\" : \"0\" , \"sendEmail\" : \"1\" , \"registerDate\" : \"2019-05-10 06:54:13\" , \"lastvisitDate\" : \"2019-08-27 12:44:44\" , \"activation\" : \"0\" , \"params\" : \"\" , \"groups\" : { \"8\" : \"8\" }, \"guest\" : 0 } } As described in step 3.0, you can call the APIs you have built from the app and use those. Tip If you set up SEF, and have created menu for com_api (with api as alias), you can use SEF URLs like below instead of the one used in above example {{host}}/api/users/user/619","title":"Mobile App Use Case"},{"location":"joomla-rest-api/com-api-mobile-app-use-case/#steps-for-com_api-as-rest-api-provider","text":"","title":"Steps for com_api as Rest API provider"},{"location":"joomla-rest-api/com-api-mobile-app-use-case/#steps-to-get-auth-token","text":"1.1 From the mobile app, when user wants to login for very first time - user will enter username and password in the mobile application login form. 1.2 Your mobile app will catch those credentials, 1.3 and make an API call as below Example: Method POST URL { {host } }/index.php?option=com_api&app=users&resource=login&format=raw Headers Content-Type: application/x-www-form-urlencoded Post Data username: user entered value password: user entered value CURL example curl --location --request POST 'http://{{host}}/index.php?app=users&resource=login&option=com_api&format=raw' \\ --form 'username=example@gmail.com' \\ --form 'password=passwordGoesHere' Response If credentials are correct, you will get a response, which looks like { \"err_msg\" : \"\" , \"err_code\" : \"\" , \"response_id\" : 214 , \"api\" : \"users.login\" , \"version\" : \"\" , \"data\" : { \"auth\" : \"c8b16517a0a21c446f1ee9980944cd7e\" , \"code\" : \"200\" , \"id\" : \"653\" , \"jwt\" : \"eyJ0eXAiOiJKV1QiLCJhreebGciOiJIUzI1NiJ9.eyJpZCI6IjY1MyJ9.rere-ZAhpXYXvCHuZbqqTmtwjUvlv8ZnA2t-PxzI\" } }","title":"Steps to get auth token"},{"location":"joomla-rest-api/com-api-mobile-app-use-case/#steps-to-use-auth-token-for-subsequent-api-calls","text":"2.1 Once you get the response to above, you get an auth key, which you can use for next API calls 2.2 Your mobile app should store the auth key lets say local storage or whatever way you prefer \"auth\": \"c8b16517a0a21c446f1ee9980944cd7e\" 3.0 Now, for subsequent API calls you can pass this auth key in the header and still access APIs without passing username and password. Example: Method GET URL { {host } }/index.php?option=com_api&app=users&resource=user&format=raw&id= 619 Headers Content-Type: application/x-www-form-urlencoded Authorization: Bearer c 8 b 16517 a 0 a 21 c 446 f 1 ee 9980944 cd 7 e CURL example curl --location --request GET 'http://{{host}}/index.php?app=users&resource=login&option=com_api&format=raw' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'Authorization: Bearer c8b16517a0a21c446f1ee9980944cd7e' Response You will get a response, which looks like { \"err_msg\" : \"\" , \"err_code\" : \"\" , \"response_id\" : 218 , \"api\" : \"users.user\" , \"version\" : \"\" , \"data\" : { \"id\" : \"619\" , \"name\" : \"asdasd adasda\" , \"username\" : \"asdadad\" , \"email\" : \"asdsd@asdasd.com\" , \"block\" : \"0\" , \"sendEmail\" : \"1\" , \"registerDate\" : \"2019-05-10 06:54:13\" , \"lastvisitDate\" : \"2019-08-27 12:44:44\" , \"activation\" : \"0\" , \"params\" : \"\" , \"groups\" : { \"8\" : \"8\" }, \"guest\" : 0 } } As described in step 3.0, you can call the APIs you have built from the app and use those. Tip If you set up SEF, and have created menu for com_api (with api as alias), you can use SEF URLs like below instead of the one used in above example {{host}}/api/users/user/619","title":"Steps to use auth token for subsequent API calls"},{"location":"joomla-rest-api/com-api-plugin-development/","text":"Each resource supports the GET, POST and DELETE operations. These are exposed by creating methods of the same name, i.e. get() post() and delete() in each of the resources. If a resouce URL is accessed via HTTP POST, the post() method is called, and similarly for the rest. API plugin file structure \u00b6 language/en-GB (Resource folder having resource file, keep name same as plugin name) en-GB.plg_api_users.ini (add plugin language constant) en-GB.plg_api_users.sys.ini users (**Resources* folder having resource file, keep name same as plugin name)* login.php (Resource file) users.php (Resource file) users.php (plugin entry file) users.xml (plugin manifest file) Note You can add multiple resource in resource folder and use them for different purpose. Usually, each resource will map to an object type for your extension. Create plugin entry file users.php file \u00b6 This is the entry file for the API plugin, the things that re deifned in the file are resource locations, and making certain resources public. Below is the code for the file - <?php // Class structure example class PlgAPIUsers extends ApiPlugin { public function __construct ( & $subject , $config = array ()) { parent :: __construct ( $subject , $config = array ()); // Set resource path ApiResource :: addIncludePath ( dirname ( __FILE__ ) . '/users' ); // Load language files $lang = JFactory :: getLanguage (); $lang -> load ( 'com_users' , JPATH_ADMINISTRATOR , '' , true ); // Set the login resource to be public $this -> setResourceAccess ( 'login' , 'public' , 'post' ); } } Create resource file login.php file \u00b6 Although you can place the resource files anywhere, the recommended approach is to place them within a folder inside your plugin. Below is example code for a resource file. Notice how the methods get() and post() are implemented. The methods may return an array or an object which will be automatically converted to JSON or XML. <?php class UsersApiResourceLogin extends ApiResource { public function get () { $result = new \\stdClass ; $result -> id = 45 ; $result -> name = \"John Doe\" ; $this -> plugin -> setResponse ( $result ); } public function post () { // Add your code here $this -> plugin -> setResponse ( $result ); } } The array or object from the plugin should be set via $this->plugin->setResponse() . Error Handling \u00b6 It is possible to send HTTP errors with the right HTTP codes using the APIError::raiseError() method. Depending on the type of error you can raise different Exceptions that set the appropriate HTTP code. <?php public function post () { // Validation Error sets HTTP 400 ApiError :: raiseError ( 10001 , \"Invalid Email\" , 'APIValidationException' ); // Access Error sets HTTP 403 ApiError :: raiseError ( 11001 , \"Not authorised\" , 'APIUnauthorisedException' ); // Not Found Error sets HTTP 404 ApiError :: raiseError ( 12001 , \"Record not found\" , 'APINotFoundException' ); // General Error sets HTTP 400 ApiError :: raiseError ( 10000 , \"Bad Request\" , 'APIException' ); } You are free to specify your own error code and message. It is also possible to add more Exceptions in the components/com_api/libraries/exceptions folder. When using APIError::raiseError() there is no need to use $this->plugin->setResponse() since com_api handles the response and setting the http code. Note The exception classes extend PHP's Exception class. So you will need to use numeric only codes, since PHP does not support non-numeric Exception codes. Private and public resources \u00b6 Unless specified, all resources are private, which means an API token is needed to access. However, it is possible to make certain resource and methods public by using the setResourceAccess() access method as $this->setResourceAccess('login', 'public', 'post') ; The first parameter is the resource name, second is status (should be public to make it public) and last is HTTP method to make public. Setting a resource public will mean that the API URL for that resource will not need any authentication. Access Control \u00b6 ACL needs to be handled by the respective plugins. com_api makes a $this->user object available in the resource class. This is same as the JFactory::getUser() object for the user to whom the token belongs. It is upto the resource to use the user object and apply the necessary access control and produce authorisation errors. <?php class ExamplesApiResourceExample extends ApiResource { public function get () { // Will dump the object for the user who is making the API call var_dump ( $this -> user ); } } Create .xml file \u00b6 Finally create a manifest XML so that your plugin can be installed. Set group as 'api', add plugin name and other details. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension version= \"3.0.0\" type= \"plugin\" group= \"api\" method= \"upgrade\" > <name> YourPlugin </name> <version> 1.0 </version> <creationDate> 10/11/2016 </creationDate> <author></author> <description></description> <files> <filename plugin= \"your_plugin_name\" > your_plugin_name.php </filename> <folder> your_plugin_name </folder> </files> <languages folder= \"language\" > <language tag= \"en-GB\" > en-GB/en-GB.plg_api_plugin_name.ini </language> <language tag= \"en-GB\" > en-GB/en-GB.plg_api_plugin_name.sys.ini </language> </languages> </extension> Tips for writing plugins Think of API plugins as a replacement of controllers. Any business logic that you won't put in a controller, leave it out of the plugin too. Load and use your models in the plugin code. It is not recommended to have API specific language files unless absolutely necessary. You will ususally make plugins for an existing component, so load the language files from that component. To create the list and details for an object type, you can either add a condition based on id query parameter in the get() method, or have a separate resource for the list.","title":"Writing your own API Plugin"},{"location":"joomla-rest-api/com-api-plugin-development/#api-plugin-file-structure","text":"language/en-GB (Resource folder having resource file, keep name same as plugin name) en-GB.plg_api_users.ini (add plugin language constant) en-GB.plg_api_users.sys.ini users (**Resources* folder having resource file, keep name same as plugin name)* login.php (Resource file) users.php (Resource file) users.php (plugin entry file) users.xml (plugin manifest file) Note You can add multiple resource in resource folder and use them for different purpose. Usually, each resource will map to an object type for your extension.","title":"API plugin file structure"},{"location":"joomla-rest-api/com-api-plugin-development/#create-plugin-entry-file-usersphp-file","text":"This is the entry file for the API plugin, the things that re deifned in the file are resource locations, and making certain resources public. Below is the code for the file - <?php // Class structure example class PlgAPIUsers extends ApiPlugin { public function __construct ( & $subject , $config = array ()) { parent :: __construct ( $subject , $config = array ()); // Set resource path ApiResource :: addIncludePath ( dirname ( __FILE__ ) . '/users' ); // Load language files $lang = JFactory :: getLanguage (); $lang -> load ( 'com_users' , JPATH_ADMINISTRATOR , '' , true ); // Set the login resource to be public $this -> setResourceAccess ( 'login' , 'public' , 'post' ); } }","title":"Create plugin entry file users.php file"},{"location":"joomla-rest-api/com-api-plugin-development/#create-resource-file-loginphp-file","text":"Although you can place the resource files anywhere, the recommended approach is to place them within a folder inside your plugin. Below is example code for a resource file. Notice how the methods get() and post() are implemented. The methods may return an array or an object which will be automatically converted to JSON or XML. <?php class UsersApiResourceLogin extends ApiResource { public function get () { $result = new \\stdClass ; $result -> id = 45 ; $result -> name = \"John Doe\" ; $this -> plugin -> setResponse ( $result ); } public function post () { // Add your code here $this -> plugin -> setResponse ( $result ); } } The array or object from the plugin should be set via $this->plugin->setResponse() .","title":"Create resource file login.php file"},{"location":"joomla-rest-api/com-api-plugin-development/#error-handling","text":"It is possible to send HTTP errors with the right HTTP codes using the APIError::raiseError() method. Depending on the type of error you can raise different Exceptions that set the appropriate HTTP code. <?php public function post () { // Validation Error sets HTTP 400 ApiError :: raiseError ( 10001 , \"Invalid Email\" , 'APIValidationException' ); // Access Error sets HTTP 403 ApiError :: raiseError ( 11001 , \"Not authorised\" , 'APIUnauthorisedException' ); // Not Found Error sets HTTP 404 ApiError :: raiseError ( 12001 , \"Record not found\" , 'APINotFoundException' ); // General Error sets HTTP 400 ApiError :: raiseError ( 10000 , \"Bad Request\" , 'APIException' ); } You are free to specify your own error code and message. It is also possible to add more Exceptions in the components/com_api/libraries/exceptions folder. When using APIError::raiseError() there is no need to use $this->plugin->setResponse() since com_api handles the response and setting the http code. Note The exception classes extend PHP's Exception class. So you will need to use numeric only codes, since PHP does not support non-numeric Exception codes.","title":"Error Handling"},{"location":"joomla-rest-api/com-api-plugin-development/#private-and-public-resources","text":"Unless specified, all resources are private, which means an API token is needed to access. However, it is possible to make certain resource and methods public by using the setResourceAccess() access method as $this->setResourceAccess('login', 'public', 'post') ; The first parameter is the resource name, second is status (should be public to make it public) and last is HTTP method to make public. Setting a resource public will mean that the API URL for that resource will not need any authentication.","title":"Private and public resources"},{"location":"joomla-rest-api/com-api-plugin-development/#access-control","text":"ACL needs to be handled by the respective plugins. com_api makes a $this->user object available in the resource class. This is same as the JFactory::getUser() object for the user to whom the token belongs. It is upto the resource to use the user object and apply the necessary access control and produce authorisation errors. <?php class ExamplesApiResourceExample extends ApiResource { public function get () { // Will dump the object for the user who is making the API call var_dump ( $this -> user ); } }","title":"Access Control"},{"location":"joomla-rest-api/com-api-plugin-development/#create-xml-file","text":"Finally create a manifest XML so that your plugin can be installed. Set group as 'api', add plugin name and other details. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension version= \"3.0.0\" type= \"plugin\" group= \"api\" method= \"upgrade\" > <name> YourPlugin </name> <version> 1.0 </version> <creationDate> 10/11/2016 </creationDate> <author></author> <description></description> <files> <filename plugin= \"your_plugin_name\" > your_plugin_name.php </filename> <folder> your_plugin_name </folder> </files> <languages folder= \"language\" > <language tag= \"en-GB\" > en-GB/en-GB.plg_api_plugin_name.ini </language> <language tag= \"en-GB\" > en-GB/en-GB.plg_api_plugin_name.sys.ini </language> </languages> </extension> Tips for writing plugins Think of API plugins as a replacement of controllers. Any business logic that you won't put in a controller, leave it out of the plugin too. Load and use your models in the plugin code. It is not recommended to have API specific language files unless absolutely necessary. You will ususally make plugins for an existing component, so load the language files from that component. To create the list and details for an object type, you can either add a condition based on id query parameter in the get() method, or have a separate resource for the list.","title":"Create .xml file"},{"location":"tnc-manager/tnc-manager-overview/","text":"Terms & Conditions Manager is used to force users to accept the T&C before they can start using the site, or a part of the site. It is also possible to define multiple T&C that block different contexts. For example, you may want users to accept terms before they start writing blogs on your site. On the same site, you may want users to accept different terms before they can participate in the community. The T&C Manager allows you to do this. Additionally, it also lets you manage versions of each T&C. If a new version of a T&C is created, te user is forced to accept it again before he can access the protected parts.","title":"T & C Manager Overview"}]}